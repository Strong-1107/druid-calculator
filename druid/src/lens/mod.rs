// Copyright 2020 The Druid Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Support for lenses, a way of focusing on subfields of data.
//!
//! Lenses are useful whenever a widget only needs access to a subfield of a larger struct or
//! generally access to part of a larger value.
//!
//! For example: If one wants to embed a [`TextBox`] in a widget with a `Data` type
//! that is not `String`, they need to specify how to access a `String` from within the `Data`.
//!
//! [`TextBox`]: ../widget/struct.TextBox.html
//! ```
//! use druid::{Data, Lens, Widget, WidgetExt, widget::{TextBox, Flex}};
//!
//! #[derive(Clone, Debug, Data, Lens)]
//! struct MyState {
//!     search_term: String,
//!     scale: f64,
//!     // ...
//! }
//!
//!
//! fn my_sidebar() -> impl Widget<MyState> {
//!     // `TextBox` is of type `Widget<String>`
//!     // via `.lens` we get it to be of type `Widget<MyState>`.
//!     // `MyState::search_term` is a lens generated by the `derive(Lens)` macro,
//!     // that provides access to the search_term field.
//!     let searchbar = TextBox::new().lens(MyState::search_term);
//!
//!     // ...
//!
//!     // We can now use `searchbar` just like any other `Widget<MyState>`
//!     Flex::column().with_child(searchbar)
//! }
//! ```

#[allow(clippy::module_inception)]
#[macro_use]
mod lens;
pub use lens::{Deref, Field, Id, InArc, Index, Map, Ref, Then, Unit};
#[doc(hidden)]
pub use lens::{Lens, LensExt};

/// A lens that reverses a boolean value
///
/// # Examples
///
/// ```
/// # use druid::*;
/// use druid::lens;
///
/// #[derive(Lens)]
/// struct MyThing {
///     first: bool
/// }
///
/// let lens = lens::not(MyThing::first);
/// let mut val = MyThing { first: false };
/// assert_eq!(lens.with(&val, |v| *v), true);
/// lens.with_mut(&mut val, |v| *v = false);
/// assert_eq!(val.first, true);
/// ```
pub fn not<T>(inner: impl Lens<T, bool>) -> impl Lens<T, bool> {
    struct Not<L>(L);

    impl<T, L: Lens<T, bool>> Lens<T, bool> for Not<L> {
        fn with<V, F: FnOnce(&bool) -> V>(&self, data: &T, f: F) -> V {
            L::with(&self.0, data, move |b| f(&!*b))
        }

        fn with_mut<V, F: FnOnce(&mut bool) -> V>(&self, data: &mut T, f: F) -> V {
            L::with_mut(&self.0, data, move |b| {
                // reverse the sign for the inner lens.
                *b = !*b;
                let out = f(b);
                // reverse the sign back.
                *b = !*b;
                out
            })
        }
    }

    Not(inner)
}
